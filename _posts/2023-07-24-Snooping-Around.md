---
title: "Snooping Around"
---

When designing reactive pages which allow users to access data associated with a given entity stored in some db, it's customary to use some sort of identifier to specify it in the URL:

```https://stackoverflow.com/questions/3034861/youtube-url-algorithm```

In the above example, we see a common pattern of `[URL]/[entity-type]/[entity-id]` which involves injecting the db id (or some pseudonym for it) of the requested entity right in the URL. For public pages this approach works fine, but what if I wanted to allow selective access to it? One approach might be to require a user to log in, which would assign them some JWT which can be passed in to all requests to the server they make, verifying that they possess the correct permissions to access the page. If you go to a random ID then you'll land on a valid page, but won't have the permissions to access the data there. This approach is therefore as strong as your JWT, and is akin to the approach the Social Security Administration uses on all of our Social Security Cards in both its strengths and its weaknesses: if you take your id and increment it then you'll end up with a valid id of another person, but you might not have the other credentials to corroborate that you are who you say you are (a photo id or birth certificate). However, it allows a bad actor to know that there is a resource at a given location which can be attacked in other ways.

An approach which counters the weaknesses this one is to create some sort of pseudonym for db ids. This can be accomplished via hashing, which generates a sequence of characters that has a 1-1 relationship with the value which was hashed. While these values can be reverse-engineered via brute force testing numbers with populat hash algorithms, they can be strengthened by concatenating the id with a secret "salt", which adds an extra buffer of protection.

One technique which I was not familiar with until recently, though, is generating a randomly generated, unique key for each entity which is not dependent upon its attributes. This can be done by selecting randomized, Base64 encoded characters in a sequence. Simply generate one of these random strings, recalculate it if it's been used already, and assign it in the db to your entity. This way, if a bad actor starts trying random URL values (most of which will be misses since even a random sequence of 6 such characters has possibilities in the *trillions*), you can stop them after a number of times. Allowing a bad actor to try, say, 5 unsuccessful times to find a URL they're not supposed to have access to can result in them being blacklisted for a time from making requests with a statistically insignificant chance of success. However, the downside of this approach is that if a bad actor finds a link to a secret resource (more likely via social than software engineering), restricting access again will require a redefinition of the sequence, and everyone who has valid access to it adjusting to the new link.