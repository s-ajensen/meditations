---
title: "Ajax the Greater or Ajax the Lesser?"
---

In Reagent we are able to define dynamic pages which will mount and unmount markup on the fly using client-side javascript. This allows us to change the look of the page without (necessarily) having to make requests to the server as we would in, say, PHP where dynamically populating content usually involves making a post request to render some HTML on the server and send it back. While this can be done without any communication to the server, it's often the case that the new content we wish to update in the browser depends on some data which lives on the server or on a database somewhere. While it would *technically* be possible to load all of this data with the initial page load, it usually makes the most sense to delegate the `fetch`ing of these resources to the time at which we wish to render the component.

The simplest way to achieve this is via a pattern referred to as `AJAX`, **A**synchronous **J**avaScript **a**nd **X**ML, which utilizes a JavaScript API (usually `fetch` or `axios`) to trigger requests to the web server which send back data (not markup) which can be consumed by our application and passed to the components which need them.

For instance, suppose that I have an application that stores todo lists for a user. It may not make sense to load all of a given user's list data on initial page load either for design or performance reasons, so we may wish to simply show the user an index of their lists and allow them to select one. When a list is selected, a `GET` request is made to the server to fetch the entities in the database associated with that list, which is then returned to the browser, perhaps in `JSON` format. This payload is then passed to a function (a component), which dynamically generates markup to display it in our app.

It is *asynchronous* in the sense that it is happening in the background. The user can still interact with other parts of the page while these network requests are happening, so (ideally) the page doesn't hang or become unresponsive during this time. It also doesn't require a reload of the page, so multiple requests for content can be made simultaneously without needing to worry about managing page state between requests.

This technique for page responsiveness is incredibly effective for many use cases, but it has the downside of relying on the client to make requests to the server for content. This is disadvantageous for applications in which multiple users may be editing the same fields in tandem.

For instance, suppose that the todo app allowed multiple clients to access the same list. If a user added an item to a list, this change would not show on the page of users who had already loaded the page; it would require either a refresh of the page or another `GET` request for this data to be loaded.

In some cases, it may be acceptable to simply "poll" the server for such changes, in which case every client periodically makes such requests to the server to update their components with new changes. However, having many clients constantly using up server resources to poll new changes can negatively impact a server under load, and can be unresponsive if the time between requests is not fast enough.

To accomodate this problem, a "websocket" connection can be established between the client and server which, unlike traditional client/server relations in AJAX, allows for *bidirectional* communication between systems. In this case, when a change is made to an endpoint, this change in state is automatically sent to all clients which subsequently updates their components. When executed properly, this will allow users to feel that they are interacting with a 'live' application which is the same as other users in the same context.