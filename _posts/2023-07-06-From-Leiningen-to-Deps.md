---
title: "From Leiningen to Deps"
---

The ClojureSphere there are two primary method for managing packages, dependencies, test builds, REPLs, and all ranges of production concerns for our applications. The one I had grown accustomed to using from the beginning of my apprenticeship is known as [Leiningen](https://leiningen.org/), which allows us to define a `project.clj` file which defines many of the features which I described above.

I found `lein` to be a handy tool which allowed me to spin up a REPL, run tests, and even pull in dependencies from the web, but I ran into a brick wall when trying to import a `.jar` file into my project. It turns out that while Leiningen may be a standard for accomplishing such tasks in a Clojure project, the official (and younger) alternative comes in the form of a `deps.edn` configuration, which Clojure provides out of the box.

`deps.edn` files allow users to pull resources from any git repository, maven package, or local file. Leiningen is dependent upon the Maven repository schema, and so to accomplish the latter of these concerns I would need to virtualize such a repository on my local machine and add the jar file to it (and then provide instructions on how to do this to any consumers of my library). 

This simply wouldn't do, and thus the transition from `lein` to `deps.edn` began. First, I identified the dependencies of my project in `project.clj`:

```clojure
(defproject tic-tac-toe "0.1.0-SNAPSHOT"
  :description "tic tac toe in clojure"
  :url "https://s-ajensen.github.io/meditations/2023/06/23/Tic-Tac-Toe.html"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :main ttt.main
  :dependencies [[org.clojure/clojure "1.9.0"]
                 [org.clojure/java.jdbc "0.7.12"]
                 [org.xerial/sqlite-jdbc "3.42.0.0"]
                 [quil "3.1.0"]]
  :profiles {:dev {:dependencies [[speclj "3.4.3"]]}}
  :plugins [[speclj "3.4.3"]]
  :test-paths ["spec"])
```

Of course we need `clojure`, `speclj`, and a few other packages to manage database and ui functionality. To migrate them, I created a `deps.edn` file which looked something like this:

```clojure
{
 :paths   ["src"]
 :deps    {
           org.clojure/clojure      {:mvn/version "1.11.1"}
           org.clojure/java.jdbc    {:mvn/version "0.7.12"}
           org.xerial/sqlite-jdbc   {:mvn/version "3.42.0.0"}
           quil/quil                {:mvn/version "3.1.0"}
           }
 :aliases {
           :test {:extra-deps  {
                                speclj/speclj {:mvn/version "3.4.3"}
                                }
                  :extra-paths ["spec/"]}
           :spec  {:main-opts ["-m" "speclj.main" "-c"]}
           }
 }
```

You'll notice that they look quite similar. We define our build dependencies as well as the ones we have for testing, which we nest inside an alias. This way these libraries aren't cluttering our namespace when we want to do a production build.

The `:paths` directory specifies where Clojure will look when trying to compile our `.clj` files to Java bytecode (more on this later). 

Similarly, in our `:test` alias, we define `:extra-paths` which indicates where our test sources are. By doing so we can simply run `clj -M:test:spec` and our `:test` and `:spec` aliases will be chained together bringing in both our `speclj` dependency as well as running our tests.

This is particularly useful because projects defined by `deps.edn` play *very* nicely together. When I push this project to GitHub, I can then go to a **different** project and define its `deps.edn` like so:

```clojure
{
 :paths   ["src"]
 :deps    {
           org.clojure/clojure      {:mvn/version "1.11.1"}
           ttt/ttt                  {:git/url "https://github.com/[the repository]" :git/sha "the commit sha"}
           }
 :aliases {
           :test {:extra-deps  {
                                speclj/speclj {:mvn/version "3.4.3"}
                                }
                  :extra-paths ["spec/"]}
           :spec  {:main-opts ["-m" "speclj.main" "-c"]}
           }
 }
```

Now when I compile the new project, the library in my git repository will automatically be cloned and injected to my classpath for when I need to run my Clojure project, and I can quality its namespaces by using a `ttt.ns` prefix â€” very useful!

This accomplished most of what I needed to do, but there was the last caveat of Intellij screaming at me that I deleted my project when I got rid of `project.clj`. To fix this, I went to my terminal and listed out all of the files in my project directory

```
- .idea
- .git/
- resources/
- src/
- spec/
- deps.edn
- tic-tac-toe.iml
- README.md
```

Two of these, `.idea` and `tic-tac-toe.iml` are generated by Intellij to keep track of your project. **I delete these**. Then, it was as simple as `File > New > Project From Existing Sources` in Intellij and selecting `Deps` as my project structure. It recognized my `deps.edn` file and indexed my project appropriately without my having to move a muscle. Very nice!