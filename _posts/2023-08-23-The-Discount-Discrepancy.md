---
title: "The Discount Discrepancy"
---

Part of a story that I worked on last week involved implementing some new rules for applying discounts to groups of episodes in a series on our cleancoders.com site. The goal was such that if a user buy an entire series of videos (or if their purchase resulted in them owning the entire series), they get a nice littl 15% discount—simple enough. However, what wasn't taken into account when defining the requirements of this story is that episodes can optionally be part of a subseries. As a user, these are largely indistinguishable: if a series has 80 episodes, it may be split into subseries chunks of 10 apiece. To the user, these look like a series, and so they expect a discount, but since the logic only applied to the entire series, they would have to purchase all 80 for the discount to apply. This is not desireable from a business perspective.

Therefore, the requirements were changed such that if a user buys an entire series *or* subseries, then the 15% discount applies. Well this added some complexity...

Notice that I said that an episode can *optionaly* belong to a subseries; there is no guarantee that it does like with belonging to a series. The way I implemented this functionality when it simply applied to a series was to grab the the episodes from a series a user was buying an episode from. If the episodes in the cart combined with the episodes that they owned resulted cumulatively in them owning the entire series, then apply the discount. But with this added requirement I have to pull the episodes from a given *subseries* that an episode is a part of—if it's a part of one at all—and if there is no such subseries, pull the episodes from the series, applying the same logic to both.

To implement this with as little code duplication as possible I wrote a small function that would get the "parent" of an episode. If the episode has a subseries component, then it will be the subseries, otherwise it defaults to the series, an attribute it's guaranteed to have. Using datomic, I can pull an entity based simply on its `:id` without having to specify a type, so I can collect the corresponding series *or* subseries entities and put them into some sort of collection.

I then wrote another function that would check whether an entity is a series or subseries, and grab the episodes associated with it, and generate a map based on the "parent" id that it used to collect it. The result is that I now have a map that is keyed based on the id of the series or subseries, the values of which are the associated episodes. I can then apply the same logic as before where I compare the items in the cart and the user's library with the episodes in this map for a given "parent" without having to run messy checks to determine what kind of thing it is—a kind of functional polymorphism that doesn't involve any fancy interfaces or protocols.